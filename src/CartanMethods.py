# -*- coding: utf-8 -*-

"""
Created on Mon Dec 21 15:19:18 2020

A collection of method to calculate Useful Cartan Methods

@author: Thomas Steckmann
@author: Efekan Kokcu
"""
__docformat__ = "google"
from src.PauliOps import commutatePauliString




def included(g,m):
    '''Following function returns 0 if tuple m is not incu=luded in tuple list g, returns 1 if it is included.
    
    Args:
        g (List of Tuples): 
            The List of Pauli string elements in the Hamiltonian Algebra 𝖌(H)
        m (Tuple of 0,1,2,3):
            Pauli string in the set 𝖒

    Returns: 
        1 if m is in g
        0 if not
    '''
    L = len(g)
    res = 0    
    for i in range(L):
        if g[i]==m:
            res = 1
            break
    
    return res


def makeGroup(g):
    '''
    Following function returns a closure of a given list of pauli strings (g). The list doesn't include any coefficients, it is just
    a tuple like (0,2,3) representing IYZ.

    Args:
        g (List of Tuples):
            A set of Pauli Strings

    Returns:
        g(H), the Hamiltonian Algebra generated by the input g
    '''
    
    flag = 0
    while (flag == 0):
        flag = 1
        L = len(g)
        #initialize commutations
        coms = []

        #calculate all possible commutations and
        for i in range(L):
            for j in range(i,L):
                m = commutatePauliString(1,g[i],1,g[j])
                
                
                #add all new ones to the list
                if (abs(m[0])>0) & (included(coms,m[1])==0) & (included(g,m[1])==0):
                    #set flag to 0 whenever there is a new term to be added
                    flag = 0
                    coms.append(m[1])

        #then merge initial list with these new commutations
        g = g + coms
        #print(g)
    return g

def evenOdd(g):
    """ Partitions the Algebra by counting the number of non-idenity Pauli elements

    Args:
        g (List of Tuples):
            The Algebra to partition
    
    Returns:
        k (List of Tuples):
            The List of Pauli Strings with Odd non-identity terms
        m (List of Tuples):
            The List of Pauli Strings with Even non-idenity terms
    """
    k = []
    m = []
    
    for i in range(len(g)):
        elem = g[i]
        count = 0
        for j in range(len(elem)):
            if elem[j] > 0:
                count=count+1
        if count%2 == 0:
            m.append(elem)
        else:
            k.append(elem)
            
    return k,m
 


def elemcount(g,element):
    k = []
    m = []
    
    for i in range(len(g)):
        elem = g[i]
        count = 0
        for j in range(len(elem)):
            if elem[j] == element:
                count=count+1
        if count%2 == 0:
            m.append(elem)
        else:
            k.append(elem)
        
    return k,m


def knejaGlaser(g,element):
    '''
    Following one is the Kneja Glaser decomposition. 
    It corresponds to \theta(g) = III...IZ g III..IZ
    ''' 
    k = []
    m = []
    
    for i in range(len(g)):
        elem = g[i]
        last = elem[len(elem)-1]
        if  (last == element) | (last == 0):
            m.append(elem)
        else:
            k.append(elem)
        
    return k,m


def furtherdecompose(k):
    
    knew = []
    mnew = []

    index = 0
    while len(mnew) == 0:

        knew = []
        term = k[index]
        knew.append(term)
        for i in range(len(k)):
            if i != index:
                comm = commutatePauliString(1,k[index],1,k[i])
                if comm[0] == 0:
                    knew.append(k[i])
                else:
                    mnew.append(k[i])
                
        index = index + 1
    
    
            
    return knew, mnew




    
def createK(abeliank, hlist):
    """Used to format the output as ex. kh'khkh'k

    Not Currently in use

    Args:
        abeliank: List of Tuples 
            Fully decomposed k elements
        hlist: List of lists of Tuples
            One for each level of decomposition
            
    """
    
    if len(hlist) == 0:
        return abeliank
    else:
        newhlist = hlist.copy()

        h = newhlist[0]
        newhlist.pop(0)
        
        oneless = createK(abeliank,newhlist)
        
        return  oneless + h + oneless 
    
    
    

def decomposeToCommuting(k):
    '''Decomposed untill it reaches an Abelian k, and returns a list that is ready to be put into the 'k' parameter in funky.

    Not Currently in use. Instead, train optimizer on Sequence of Exponentials: e^k0 @ e^k1 instead of e^(k0 + k1)
    
    Args:
        k (List of Tuples): K subalgebra
    
    Returns:
        Tuple List [k',h',k'], Where each is a list of Tuples
        or [k'',h'',k'',h',k'',h'',k''], etc. 
        
    '''
    
    flag = 1
    
    knew = k.copy()
    
    klist = []
    hlist = []
    while flag == 1:
        flag = 0
        for i in range(len(knew)):
            for j in range(i+1,len(knew)):
                comm = commutatePauliString(1, knew[i], 1, knew[j])
                if comm[0] != 0:
                    flag = 1
                    break
        
        if flag == 1:
            print(len(knew))
            [knew, mnew] = furtherdecompose(knew)
            hnew = getsubalgebra(mnew)
            
            klist.append(knew)
            hlist.append(hnew)
            
    return createK(knew,hlist)
            
            
                    
            


def getsubalgebra(m):
    """
    Starts with an empty list, every element that commutes with the first element of H
    """
    h = []
    for i in range(len(m)):
        flag = 0
        for j in range(len(h)):
            comm = commutatePauliString(1, h[j], 1, m[i])
            if comm[0] != 0:
                flag = 1
                break
        if flag == 0:
            h.append(m[i]) 
            
    return h


def getsubalgebraelem(m, elemlist):
    """
    Takes an imput "seed" element, find all the elements that commute
    """
    h = elemlist.copy()
    for i in range(len(m)):
        flag = 0
        for j in range(len(h)):
            if m[i] == h[j]:
                flag = 1
                break
                
            comm = commutatePauliString(1, h[j], 1, m[i])
            if comm[0] != 0:
                flag = 1
                break
        if flag == 0:
            h.append(m[i]) 
            
    return h
