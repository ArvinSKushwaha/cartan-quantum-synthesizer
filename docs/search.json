[{"fullname": "CQS", "modulename": "CQS", "qualname": "", "type": "module", "doc": "<p>Welcome to the Cartan Quantum Synthesizer package. For useage examples, please see package.util.examples or the README</p>\n\n<h2 id=\"general-usage\">General Usage:</h2>\n\n<p>This package makes use of three object classes: The Hamiltonian, the Cartan, and the FindParameters objects.</p>\n\n<ol>\n    <li> <code>Hamiltonian</code>: The Hamiltonian object is used to construct information about the model that you wish to simulate. There are predefined models that can be used for example implementation, the user can define a custom Hamiltonian and pass it to the object, the user can combine existing Hamiltonians to generate the desired Hamiltonian (ex. XY + transverse field), or the user can define their own input. This is designed to be relatively straightforward, and the other definitions can serve as examples </li>\n    <li> <code>Cartan</code>: The Cartan object is used to define a cartan decomposition on the \"Hamiltonian Algebra\" generated by Hamiltonian object. The \"Hamiltonian Algebra, g(H) or g, is defined as the set of Pauli Strings that can be generated through nested commutators on the Hamiltonian. Thus, g(H) is a closed Lie algebra. We can then perform a Cartan decomposition, which splits g into two components, k and m, based on some involution. The Cartan object has a list of predefined Cartan involutions, although users are encouraged to add an name their own implementations. Finally, the Hamiltonian algebra has as Cartan Subalgebra h, which is a maximal abelian subalgebra that is contained within the m partition. This is generated by the object.  After generated the Cartan object, the involution (k and m) can be altered, and h can be regenerated based on a list of commuting terms in m. h is generally not unique. </li>\n    <li> <code>FindParameters</code>: The FindParameters object optimizes the terms in the cartan decomposition to generate a time evolution circuit for the Hamiltonian. For details of the theory, please see the paper. The Find Parameters object relies on a cost function formulated by Earp and Pachos and improved in the original paper by Kokcu et. al. The Find Parameters object takes a filename, a Cartan object (which contains a Hamiltonian object), and allows for changes in the optimizer function (ex. BFGS gradient decent or Powell), or the optimization accuracy. Warning: Runtime scales quickly with system size. </li>\n</ol>\n\n<p>package.util contains functions useful for generating the above objects or for verifying the correctness through exact matrix exponentiation. These functions might be generally useful, so they are set-aside from the above objects. </p>\n\n<p>Finally, the examples file provides code for verifying the correctness of the methods and for understanding the usage.</p>\n"}, {"fullname": "CQS.examples", "modulename": "CQS.examples", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.examples.CartanTesting", "modulename": "CQS.examples.CartanTesting", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.examples.HamiltonianTesting", "modulename": "CQS.examples.HamiltonianTesting", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.examples.ParametersTesting", "modulename": "CQS.examples.ParametersTesting", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.examples.tfim_old_code", "modulename": "CQS.examples.tfim_old_code", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.examples.tfim_old_code.ops", "modulename": "CQS.examples.tfim_old_code", "qualname": "ops", "type": "variable", "doc": "<h6 id=\"rules\">RULES</h6>\n\n<blockquote>\n  <p>Used to find the multiplication between two paulis represented as indices in a tuple (I == 0, X == 1, Y == 2, Z == 3)</p>\n</blockquote>\n\n<p>The operation is (index1 + index2*RULES[index1] % 4) = Pauli Matrix result as an index</p>\n\n<p>I * anything: 0 + (Index2)<em>1 = index2\nX * anythong: (1 + (Index2)</em>3 % 4) gives\n                                         1 + 0 = 1 for I, \n                                         (1 + 1<em>3) % 4 = 0 for X\n                                         (1 + 2</em>3) % 4 = 7 % 4 = 3 for Y\n                                         (1 + 3*3) % 4 = 10 % 4 = 2 for Z as index2\nThese can easily be expanded for Y and Z</p>\n"}, {"fullname": "CQS.examples.tfim_old_code.RULES", "modulename": "CQS.examples.tfim_old_code", "qualname": "RULES", "type": "variable", "doc": "<p>SIGN_RULES: \n    Gives the multiplication sign rules for multiplying Pauli Matricies (ex. X*Y -> iZ)</p>\n\n<p>I  X  Y  Z\nI +  +  +  +\nX +  +  +i -i\nY +  -i +  +i\nZ +  +i -i +</p>\n\n<p>Order: row * column</p>\n"}, {"fullname": "CQS.examples.tfim_old_code.com_coefs", "modulename": "CQS.examples.tfim_old_code", "qualname": "com_coefs", "type": "variable", "doc": "<p>Sets the global tuples up there and generates commutation table, so that we wouldn't have to calculate their commutation again and again.</p>\n"}, {"fullname": "CQS.examples.tfim_old_code.set_tuples", "modulename": "CQS.examples.tfim_old_code", "qualname": "set_tuples", "type": "function", "doc": "<p></p>\n", "parameters": ["k", "m", "h"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.commutatePauliString", "modulename": "CQS.examples.tfim_old_code", "qualname": "commutatePauliString", "type": "function", "doc": "<p></p>\n", "parameters": ["a", "tupleA", "b", "tupleB"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.multiplyPauliString", "modulename": "CQS.examples.tfim_old_code", "qualname": "multiplyPauliString", "type": "function", "doc": "<p></p>\n", "parameters": ["a", "tupleA", "b", "tupleB"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.multiplyLinCombRound", "modulename": "CQS.examples.tfim_old_code", "qualname": "multiplyLinCombRound", "type": "function", "doc": "<p></p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB", "accur"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.commutateLinComb", "modulename": "CQS.examples.tfim_old_code", "qualname": "commutateLinComb", "type": "function", "doc": "<p>AB = multiplyLinCombRound(A,tuplesA,B,tuplesB, accur)\nBA = multiplyLinCombRound(B,tuplesB,A,tuplesA, accur)</p>\n\n<p>for i in range(len(BA[0])):\n    BA[0][i] = -BA[0][i]</p>\n\n<p>coefs = AB[0] + BA[0]\ntuples = AB[1] + BA[1]</p>\n\n<p>simplifyLinComb(coefs,tuples)</p>\n\n<p>return coefs,tuples</p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB", "accur"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.simplifyLinComb", "modulename": "CQS.examples.tfim_old_code", "qualname": "simplifyLinComb", "type": "function", "doc": "<p></p>\n", "parameters": ["A", "tuples"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.getmatrixterm", "modulename": "CQS.examples.tfim_old_code", "qualname": "getmatrixterm", "type": "function", "doc": "<p></p>\n", "parameters": ["pterm"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.getmatrices", "modulename": "CQS.examples.tfim_old_code", "qualname": "getmatrices", "type": "function", "doc": "<p></p>\n", "parameters": ["tuples"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.getmatrix", "modulename": "CQS.examples.tfim_old_code", "qualname": "getmatrix", "type": "function", "doc": "<p></p>\n", "parameters": ["coefs", "tuples"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.included", "modulename": "CQS.examples.tfim_old_code", "qualname": "included", "type": "function", "doc": "<p></p>\n", "parameters": ["g", "m"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.makeGroup", "modulename": "CQS.examples.tfim_old_code", "qualname": "makeGroup", "type": "function", "doc": "<p></p>\n", "parameters": ["g"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.evenodd", "modulename": "CQS.examples.tfim_old_code", "qualname": "evenodd", "type": "function", "doc": "<p></p>\n", "parameters": ["g"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.elemcount", "modulename": "CQS.examples.tfim_old_code", "qualname": "elemcount", "type": "function", "doc": "<p></p>\n", "parameters": ["g", "element"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.knejaGlaser", "modulename": "CQS.examples.tfim_old_code", "qualname": "knejaGlaser", "type": "function", "doc": "<p></p>\n", "parameters": ["g", "element"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.createK", "modulename": "CQS.examples.tfim_old_code", "qualname": "createK", "type": "function", "doc": "<p></p>\n", "parameters": ["abeliank", "hlist"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.getsubalgebra", "modulename": "CQS.examples.tfim_old_code", "qualname": "getsubalgebra", "type": "function", "doc": "<p></p>\n", "parameters": ["m"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.getsubalgebraelem", "modulename": "CQS.examples.tfim_old_code", "qualname": "getsubalgebraelem", "type": "function", "doc": "<p></p>\n", "parameters": ["m", "elemlist"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.printlist", "modulename": "CQS.examples.tfim_old_code", "qualname": "printlist", "type": "function", "doc": "<p></p>\n", "parameters": ["tuples"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.cleancoefs", "modulename": "CQS.examples.tfim_old_code", "qualname": "cleancoefs", "type": "function", "doc": "<p></p>\n", "parameters": ["coefs", "accur"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.printterms", "modulename": "CQS.examples.tfim_old_code", "qualname": "printterms", "type": "function", "doc": "<p></p>\n", "parameters": ["coefs", "tuples"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.paulilabel", "modulename": "CQS.examples.tfim_old_code", "qualname": "paulilabel", "type": "function", "doc": "<p></p>\n", "parameters": ["p"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.adj_action", "modulename": "CQS.examples.tfim_old_code", "qualname": "adj_action", "type": "function", "doc": "<p></p>\n", "parameters": ["theta", "k", "coefs", "tuples"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.funkygeneral", "modulename": "CQS.examples.tfim_old_code", "qualname": "funkygeneral", "type": "function", "doc": "<p></p>\n", "parameters": ["thetas1", "thetas2", "k_ints", "k", "h", "Hcoefs", "Htuples", "accur", "index"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.funky", "modulename": "CQS.examples.tfim_old_code", "qualname": "funky", "type": "function", "doc": "<p></p>\n", "parameters": ["thetas", "k_ints", "k", "h", "Hcoefs", "Htuples", "accur"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.gradfunky", "modulename": "CQS.examples.tfim_old_code", "qualname": "gradfunky", "type": "function", "doc": "<p></p>\n", "parameters": ["thetas", "k_ints", "k", "h", "Hcoefs", "Htuples", "accur"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.gethVecFromk", "modulename": "CQS.examples.tfim_old_code", "qualname": "gethVecFromk", "type": "function", "doc": "<p></p>\n", "parameters": ["thetas", "k", "Hcoefs", "Htuples"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.errorhVec", "modulename": "CQS.examples.tfim_old_code", "qualname": "errorhVec", "type": "function", "doc": "<p></p>\n", "parameters": ["hcoefs", "htuples", "h"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.optimize", "modulename": "CQS.examples.tfim_old_code", "qualname": "optimize", "type": "function", "doc": "<p></p>\n", "parameters": ["initialGuess", "accuracy", "steps", "k_ints", "k", "h", "Hcoefs", "Htuples", "accur", "optimizerType", "sym"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.hubbard", "modulename": "CQS.examples.tfim_old_code", "qualname": "hubbard", "type": "function", "doc": "<p></p>\n", "parameters": ["N"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.xymodel", "modulename": "CQS.examples.tfim_old_code", "qualname": "xymodel", "type": "function", "doc": "<p></p>\n", "parameters": ["N", "bc"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.xymodel_2nd", "modulename": "CQS.examples.tfim_old_code", "qualname": "xymodel_2nd", "type": "function", "doc": "<p></p>\n", "parameters": ["N", "bc"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.kitaev", "modulename": "CQS.examples.tfim_old_code", "qualname": "kitaev", "type": "function", "doc": "<p></p>\n", "parameters": ["N", "bc"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.kitaevHoneyComb", "modulename": "CQS.examples.tfim_old_code", "qualname": "kitaevHoneyComb", "type": "function", "doc": "<p></p>\n", "parameters": ["length", "count"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.heisenberg", "modulename": "CQS.examples.tfim_old_code", "qualname": "heisenberg", "type": "function", "doc": "<p></p>\n", "parameters": ["N", "bc"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.tfim", "modulename": "CQS.examples.tfim_old_code", "qualname": "tfim", "type": "function", "doc": "<p></p>\n", "parameters": ["N", "bc"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.tfxy", "modulename": "CQS.examples.tfim_old_code", "qualname": "tfxy", "type": "function", "doc": "<p></p>\n", "parameters": ["N", "bc"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.getpaulirep", "modulename": "CQS.examples.tfim_old_code", "qualname": "getpaulirep", "type": "function", "doc": "<p></p>\n", "parameters": ["M", "N"], "funcdef": "def"}, {"fullname": "CQS.examples.tfim_old_code.tfxyresults", "modulename": "CQS.examples.tfim_old_code", "qualname": "tfxyresults", "type": "function", "doc": "<p></p>\n", "parameters": ["N", "accur", "partial", "devcount", "maxdev", "rep", "sym"], "funcdef": "def"}, {"fullname": "CQS.methods", "modulename": "CQS.methods", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.methods.Hamiltonian", "modulename": "CQS.methods", "qualname": "Hamiltonian", "type": "class", "doc": "<p>Class contains information about the Hamiltonian to be decomposed.</p>\n\n<h2 id=\"functionality\">Functionality:</h2>\n\n<ul>\n<li>Build Hamiltonians from prebuilt Spin models</li>\n<li>Add custom Hamiltonians </li>\n</ul>\n\n<p>TODO:</p>\n\n<ul>\n<li>Add Hubbard Model</li>\n</ul>\n\n<p>Authors:</p>\n\n<ul>\n<li>Thomas Steckmann</li>\n<li>Efekan Kokcu</li>\n</ul>\n"}, {"fullname": "CQS.methods.Hamiltonian.__init__", "modulename": "CQS.methods", "qualname": "Hamiltonian.__init__", "type": "function", "doc": "<p>Initializes an emtpy Hamiltnoan, unless name is specified</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>qubits (int):</strong>  The number of lattice points the Hamiltonisn svyd on</li>\n<li><p><strong>name (List of Tuples):</strong>  Easily build Hamiltonians from native models. </p>\n\n<h3 id=\"options\">Options:</h3>\n\n<ul>\n<li><code>[(coefficient, 'modelname', periodic boundary condisitons boolian)]</code> - Builds a single Hamiltonian with constant coefficient. Periodic boundary conditions are true or false, false is assumed if not specified</li>\n<li><code>[([list of coefficients], 'modelname')]</code> - Populates the Hamiltonian using the list of coefficients. Lengths must match</li>\n<li><p><code>[(coefficient, 'modelname1'),([list of coefficients], 'modelname2')]</code> - Combines two Hamiltonains. Order my alter default choice of \ud835\udd8d</p>\n\n<h4 id=\"examples\">Examples:</h4></li>\n<li><p><code>[(1,'xy', True)]</code> on three qubits gives: XXI + YYI + IXX + IYY + XIX + YIY</p></li>\n<li><p><code>[([1,2],'kitaevEven')]</code> on three qubits gives: 1<em>XXI + 2</em>IYY </p>\n\n<h3 id=\"currently-implemented-models\">Currently Implemented Models:</h3></li>\n<li><p>xy: (XX + YY)</p></li>\n<li>xx: (XXI + IXX)</li>\n<li>yy: (YYI + IYY)</li>\n<li>zz: (ZZI + IZZ)</li>\n<li>tfim: (ZZ + XI + IX)</li>\n<li>tfxy: (XX + YY + ZI + IZ)</li>\n<li>transverse_z: (IZ + ZI)</li>\n<li>kitaev_even: (XXI + IYY)</li>\n<li>kitaev_odd: (YYI + IXX)</li>\n<li>heisenberg: (XX + YY + ZZ)</li>\n<li>TODO: hubbard: (XXII + YYII + IIXX + IIYY + ZIZI + IZIZ)</li>\n</ul></li>\n</ul>\n", "parameters": ["self", "sites", "name"], "funcdef": "def"}, {"fullname": "CQS.methods.Hamiltonian.addModel", "modulename": "CQS.methods", "qualname": "Hamiltonian.addModel", "type": "function", "doc": "<p>Adds a predefined model to the Hamiltonian object</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>pair (Tuple):</strong>   ### Currently Implemented Models:\n<ul>\n<li>xy: (XX + YY)</li>\n<li>xx: (XXI + IXX)</li>\n<li>yy: (YYI + IYY)</li>\n<li>zz: (ZZI + IZZ)</li>\n<li>tfim: (ZZ + XI + IX)</li>\n<li>tfxy: (XX + YY + ZI + IZ)</li>\n<li>transverse_z: (IZ + ZI)</li>\n<li>kitaev_even: (XXI + IYY)</li>\n<li>kitaev_odd: (YYI + IXX)</li>\n<li>heisenberg: (XX + YY + ZZ)</li>\n<li>TODO: hubbard: (XXII + YYII + IIXX + IIYY + ZIZI + IZIZ)</li>\n</ul></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError:</strong>   Coefficient list length mismatch</li>\n<li><strong>Exception:</strong>  Invalid model type input</li>\n</ul>\n", "parameters": ["self", "pair"], "funcdef": "def"}, {"fullname": "CQS.methods.Hamiltonian.addTerms", "modulename": "CQS.methods", "qualname": "Hamiltonian.addTerms", "type": "function", "doc": "<p>Adds custom elements to build out the Hamiltonian</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>pair (List of Tuples or Tuple of Lists or Tuple):</strong>  Formatted as either\n<ul>\n<li><code>[(coefficient, PauliString), (coefficient, PauliStringTuple),...]</code></li>\n<li><code>(coefficient, (PauliString))</code></li>\n<li>`([coefficienList],[(PauliStringList)])</li>\n</ul></li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<blockquote>\n  <ul>\n  <li><code>Hamiltonian.addTerms((0.45, (1,3,2,0,0,0)))</code></li>\n  <li>`Hamiltonian.addTerms([(1,(1,1,0,0)),(2,(2,2,0,0))])</li>\n  <li><code>Hamiltonian.addTerms(([co1, co2, co3, ...],[(PauliString1),(PauliString2),(PauliString3)...])</code></li>\n  </ul>\n</blockquote>\n", "parameters": ["self", "pairs"], "funcdef": "def"}, {"fullname": "CQS.methods.Hamiltonian.removeTerm", "modulename": "CQS.methods", "qualname": "Hamiltonian.removeTerm", "type": "function", "doc": "<p>Removes the term matching the tuple input. Used for trimming terms off the Hamiltonian</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tup (tuple):</strong>  A (pauliString)</li>\n</ul>\n", "parameters": ["self", "tup"], "funcdef": "def"}, {"fullname": "CQS.methods.Hamiltonian.generateHamiltonian", "modulename": "CQS.methods", "qualname": "Hamiltonian.generateHamiltonian", "type": "function", "doc": "<p>Helper Function to generate Hamiltonians.</p>\n\n<p>From the model type, generates the Hamiltonian Pauli Strings</p>\n\n<p>Args: \n    modelType (Tuple of Strings): See previous documentation\n    closed (bool): \n        True if the model is period.</p>\n", "parameters": ["self", "modelType", "closed"], "funcdef": "def"}, {"fullname": "CQS.methods.Hamiltonian.getHamiltonian", "modulename": "CQS.methods", "qualname": "Hamiltonian.getHamiltonian", "type": "function", "doc": "<p>Based on the type, returns the Hamiltonian from the object and formats it.\n       Args:\n           type (String, default = 'tuples'): Specifies the return type of the function.\n               Valid inputs:</p>\n\n<pre><code>            - 'tuples': Return formatted as `[(coefficient, (PauliString), ... ]`\n\n            - 'printTuples': Prints out to the console ``(coefficient, (PauliString))\n</code></pre>\n\n<p>...``</p>\n\n<pre><code>            - 'printText': Prints out ``'coefficient * 'PauliString' + ....``\n\n            - 'text': Return formatted as a list of `[[coefficient, 'PauliString']]`\n\n   Returns:\n       For type=`'tuples'` or type=`'text'`, returns\n\n       - `'tuples'`: A list of Coefficient, (PauliString) Tuple pairs\n       - `'text'`: A List of Coefficient 'PauliString' List pairs\n\n   Raises:\n       ValueError: Invalid type\n</code></pre>\n", "parameters": ["self", "type"], "funcdef": "def"}, {"fullname": "CQS.methods.Cartan", "modulename": "CQS.methods", "qualname": "Cartan", "type": "class", "doc": "<p>Class to contain the options for performing Cartan Decomposition on a Hamiltonian</p>\n\n<h1 id=\"object-containing-the-functions-and-data-required-to-generate-a-cartan-decomposition-from-a-given-hamiltonian\">Object containing the functions and data required to generate a Cartan Decomposition from a given Hamiltonian.</h1>\n\n<p>from object_based.PauliOps import commutatePauliString</p>\n\n<p>TODO:</p>\n\n<ul>\n<li>Add in k simplification functions</li>\n</ul>\n\n<p>Authors:</p>\n\n<ul>\n<li>Thomas Steckmann</li>\n<li>Efekan Kokcu</li>\n</ul>\n\n<p>Functionality:</p>\n\n<ul>\n<li>Generate Hamiltonian Algebra</li>\n<li>Generate k, m, h partition</li>\n<li>Choose involution (Default - Even/Odd)</li>\n<li>Seed choice of h</li>\n<li>Modify k (Additional Decomposition, TODO: Abelian Decomposition, Piling)</li>\n</ul>\n"}, {"fullname": "CQS.methods.Cartan.__init__", "modulename": "CQS.methods", "qualname": "Cartan.__init__", "type": "function", "doc": "<p>Generates the Cartan Object</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>hamObj (Hamiltonian):</strong>  Passes a Hamiltonian Object containing the full information about the system</li>\n<li><p><strong>involution (String, default='evenOdd'):</strong>  Allows a choice of the k,m involuiton</p>\n\n<p>Options:</p>\n\n<ul>\n<li><code>'evenOdd'</code>: m contains an even number of non-identity pauli terms in each string, k contains an odd nunber of non-idenity elements</li>\n<li><code>'knejaGlaser'</code>: m contains elements ending in Y or X, k contains elements ending in I or Z</li>\n<li><code>'count' + 'X', 'Y', or 'Z'</code>: Counts of the number of the specified Pauli Tuple. Even count in m, odd in k</li>\n</ul></li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>hamiltonian (::hamiltonian:: object):</strong>  Allows access to HCoefficients and HTuples</li>\n<li><strong>HTuples (List of Tuples):</strong>  Copies over the HTuples from the hamiltonian object</li>\n<li><strong>g (List of Tuples):</strong>  Generates formatted like k + h + (m without h)</li>\n<li><strong>k (List of Tuples):</strong>  Specified by the decomposition. Changing k regenerates h and the order of g (g = k + h + (m\\h))</li>\n<li><strong>h (List of Tuples):</strong>  Specified by SubAlgebra(). Defaults to seeding by m, otherwise allows for inclusion of specific elements</li>\n</ul>\n", "parameters": ["self", "hamObj", "involution"], "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.decompose", "modulename": "CQS.methods", "qualname": "Cartan.decompose", "type": "function", "doc": "<p>Sets a new Involution using a switch. Regenerates h using the default first element in m</p>\n\n<h6 id=\"options\">Options</h6>\n\n<blockquote>\n  <ul>\n  <li><code>'evenOdd'</code>: m contains an even number of non-identity pauli terms in each string, k contains an odd nunber of non-idenity elements</li>\n  <li><code>'knejaGlaser'</code>: m contains elements ending in Y or X, k contains elements ending in I or Z</li>\n  <li><code>'count' + 'X', 'Y', or 'Z'</code>: Counts of the number of the specified Pauli Tuple. Even count in m, odd in k</li>\n  </ul>\n</blockquote>\n", "parameters": ["self", "involutionName"], "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.makeGroup", "modulename": "CQS.methods", "qualname": "Cartan.makeGroup", "type": "function", "doc": "<p>Returns a closure of a given list of pauli strings (g). The list doesn't include any coefficients, it is just\na tuple like (0,2,3) representing IYZ.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>g (List of Tuples):</strong>  A set of Pauli Strings</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List of Tuples: \ud835\udd8c(H), the Hamiltonian Algebra generated by the input g</p>\n</blockquote>\n", "parameters": ["self", "g"], "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.elemcount", "modulename": "CQS.methods", "qualname": "Cartan.elemcount", "type": "function", "doc": "<p>Counts the number of given elements (X,Y or Z in number), and puts even numbers in m, odd numbers in k. \nFor element=2, it corresponds to \u03b8(g) = -g^T</p>\n", "parameters": ["self", "g", "element"], "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.included", "modulename": "CQS.methods", "qualname": "Cartan.included", "type": "function", "doc": "<p>Following function returns 0 if tuple m is not incu=luded in tuple list g, returns 1 if it is included.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>g (List of Tuples):</strong>   The List of Pauli string elements in the Hamiltonian Algebra \ud835\udd8c(H)</li>\n<li><strong>m (Tuple of 0,1,2,3):</strong>  Pauli string in the set \ud835\udd92</li>\n</ul>\n\n<p>Returns: \n    1 if m is in g\n    0 if not</p>\n", "parameters": ["self", "g", "m"], "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.evenOdd", "modulename": "CQS.methods", "qualname": "Cartan.evenOdd", "type": "function", "doc": "<p>Partitions the Algebra by counting the number of non-idenity Pauli elements</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>g (List of Tuples):</strong>  The Algebra to partition</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>k (List of Tuples):\n      The List of Pauli Strings with Odd non-identity terms\n  m (List of Tuples):\n      The List of Pauli Strings with Even non-idenity terms</p>\n</blockquote>\n", "parameters": ["self", "g"], "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.knejaGlaser", "modulename": "CQS.methods", "qualname": "Cartan.knejaGlaser", "type": "function", "doc": "<p>Following one is the Kneja Glaser decomposition. \nIt corresponds to       heta(g) = III...IZ g III..IZ</p>\n", "parameters": ["self", "g"], "funcdef": "def"}, {"fullname": "CQS.methods.Cartan.subAlgebra", "modulename": "CQS.methods", "qualname": "Cartan.subAlgebra", "type": "function", "doc": "<p>Generates h from a list of Commuting elements in the seedList </p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>seedList (List of Tuples):</strong>  List of (PauliStrings). Must be commuting</li>\n</ul>\n\n<h6 id=\"todo\">TODO</h6>\n\n<blockquote>\n  <p>Verify that seedList is commuting</p>\n</blockquote>\n", "parameters": ["self", "seedList"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters", "modulename": "CQS.methods", "qualname": "FindParameters", "type": "class", "doc": "<p>From a Cartan Decomposition, runs the optimizer to find the appropriate parameters for a circuit</p>\n\n<p>Warning: Very long runtime for more than 8ish qubits</p>\n\n<p>Authors:</p>\n\n<ul>\n<li>Thomas Steckmann</li>\n<li>Efekan Kokcu</li>\n</ul>\n"}, {"fullname": "CQS.methods.FindParameters.__init__", "modulename": "CQS.methods", "qualname": "FindParameters.__init__", "type": "function", "doc": "<p>Initializing a FindParameters class automatically runs the optimizer over the Cartan decomposition and provided Hamiltonian</p>\n\n<p>If saveFileName is provided, verifies file location before proceeding, and saves the output as a csv\nIf loadFileName is provided, does not run the optimizer and instead reads data from the provided file</p>\n\n<h6 id=\"todo\">TODO</h6>\n\n<blockquote>\n  <ul>\n  <li>Write Load file functions</li>\n  </ul>\n</blockquote>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cartan (Obj Cartan):</strong>  The Cartan object containing the k,h, and Hamiltonian information</li>\n<li><strong>saveFileName (String, default=None):</strong>  path to save the output. Do not include an extension ('csv' or 'txt')</li>\n<li><strong>loadFileName (String, default=None):</strong>  path to a csv containing previous optimizer results. Do not add .csv or .txt</li>\n<li><p><strong>optimizer (String, default='BFGS'):</strong>  The Scipy optimizer to use. Easy to add new ones, but must be done manually</p>\n\n<p>Options: </p>\n\n<ul>\n<li><code>'BFGS'</code> : Uses Gradient</li>\n<li><code>'Powel'</code>: Does not use Gradient</li>\n</ul></li>\n<li><strong>accuracy (float, default=1e-5):</strong>  Optimizer convergence Criteria</li>\n<li><strong>initialGuess (List of values):</strong>  Allows the user to specify the inital guess for k. Must be correct, no input checking is currently implemented</li>\n<li><strong>steps (int):</strong>  The maximum number of optimization steps before termination</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <ul>\n  <li>Progress updates and runtime predictions</li>\n  <li>prints the results of the optimization</li>\n  </ul>\n</blockquote>\n", "parameters": ["self", "cartan", "saveFileName", "loadfileName", "optimizerMethod", "accuracy", "initialGuess", "steps"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.setCommutatorTables", "modulename": "CQS.methods", "qualname": "FindParameters.setCommutatorTables", "type": "function", "doc": "<p>Generates commutator look-up tables for the commutators of different elements</p>\n\n<p>Important: g must be ordered as k + h + (the rest of m). Does not work without this ordering</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.generateIndexLists", "modulename": "CQS.methods", "qualname": "FindParameters.generateIndexLists", "type": "function", "doc": "<p>Generates a lists for H, h, and k using indices in g instead of as lists of Tuples</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.optimize", "modulename": "CQS.methods", "qualname": "FindParameters.optimize", "type": "function", "doc": "<p>Chooses between methods of optimization. Current options are 'BFGS' and 'Powell' from scipy.optimize</p>\n\n<p>Sets the attribute kCoefs, which are the results of the optimizer</p>\n\n<p>Returns: \n    The object returned by the Scipy Optimizer. Contains information about the minimum, parameters, and a few other things</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.generalCostFunction", "modulename": "CQS.methods", "qualname": "FindParameters.generalCostFunction", "type": "function", "doc": "<p>This returns Tr(e<sup>i\u2022thetas1\u2022k1</sup>\u2022v\u2022e<sup>-thetas2\u2022k2</sup>\u2022H)\n(To make it clear, for Earp and Pachos function, we have k1=k2=k, thetas1=thetas2=thetas)</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>thetas1 (List):</strong>  The coefficients for the k_tuples on the left side</li>\n<li><strong>thetas2 (List):</strong>  The coefficients for the K_tuples on the right side</li>\n<li><strong>index (int):</strong>  The number of k elements acting on v</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tr(e<sup>i\u2022thetas1\u2022k1</sup>)\u2022v\u2022e<sup>-thetas2\u2022k2</sup>\u2022H)</p>\n</blockquote>\n\n<p>TODO: \n    * Comment the steps in this section</p>\n", "parameters": ["self", "thetas1", "thetas2", "index"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.CostFunction", "modulename": "CQS.methods", "qualname": "FindParameters.CostFunction", "type": "function", "doc": "<p>returns Tr(exp(thetas\u2022k)\u2022v\u2022exp(-thetas\u2022k)\u2022H)</p>\n", "parameters": ["self", "thetas"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.gradCostFunction", "modulename": "CQS.methods", "qualname": "FindParameters.gradCostFunction", "type": "function", "doc": "<p>returns gradient of funky. Order of derivatives is the order of the parameters thetas.</p>\n", "parameters": ["self", "thetas"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.adj_action", "modulename": "CQS.methods", "qualname": "FindParameters.adj_action", "type": "function", "doc": "<p>Computes Ad<sub>k</sub>(m) = e<sup>i\u2022theta</sup>(coefs \u2022 tuples)e<sup>-i\u2022theta</sup>\nAlso known as the Adjoint Representation</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>theta (float):</strong>  A single value, the coeffient of the k PauilString</li>\n<li><strong>k (Tuple):</strong>  A (PauliString)</li>\n<li><strong>coefs (List of floats, can be complex):</strong>  The coefficients indexed in order of the elements in tuples</li>\n<li><strong>tuples (List of tuples):</strong>  A List of (PauliStrings)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The Algebraic element in m which is the result of the Adjoint Action (Representation)</p>\n</blockquote>\n", "parameters": ["self", "theta", "k", "coefs", "tuples"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.sethVecFromk", "modulename": "CQS.methods", "qualname": "FindParameters.sethVecFromk", "type": "function", "doc": "<p>Returns h = exp(-thetas\u2022k)\u2022H\u2022exp(thetas\u2022k)</p>\n\n<p>Defines hErrorTuples and hErrorCoefs, which are the exact result of the adjoint representation. The result is in m, not in h, though it is mostly in h. </p>\n\n<p>hCoefs and hTuples are the results stripped of the components in m</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.errorhVec", "modulename": "CQS.methods", "qualname": "FindParameters.errorhVec", "type": "function", "doc": "<p>Gets the norm square of the part in hcoefs\u2022htuples that is orthogonal to Cartan subalgebra h.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.multiplyLinComb", "modulename": "CQS.methods", "qualname": "FindParameters.multiplyLinComb", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms</p>\n", "parameters": ["self", "A", "tuplesA", "B", "tuplesB"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.multiplyPauliString", "modulename": "CQS.methods", "qualname": "FindParameters.multiplyPauliString", "type": "function", "doc": "<p>Computes the multiplication of two Pauli Strings representated as a tuple</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple or index in g):</strong>  tuple represenation of the first Pauli String</li>\n<li><strong>b (np.complex128):</strong>  The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (Tuple or index in g):</strong>   tuple represenation of the second Pauli String</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result a\u2022TupleA . b\u2022TupleB = c\u2022TupleC, where c (the sign of the product of Paulis \u2022 a \u2022 b)\n  tupleC (tuple) :\n      the elementwise product of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "parameters": ["self", "a", "tupleA", "b", "tupleB"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.commutatePauliString", "modulename": "CQS.methods", "qualname": "FindParameters.commutatePauliString", "type": "function", "doc": "<p>Computes the commutator of two Pauli Strings representated as a tuple</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple, integer):</strong>   tuple represenation of the first Pauli String, or the index in the commutator table</li>\n<li><strong>b (np.complex128):</strong>   The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (tuple, int):</strong>   tuple represenation of the second Pauli String, or the index in the commutator table</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result [a\u2022TupleA,b\u2022TupleB] = c\u2022TupleC, where c is the Structure Constant \u2022 a \u2022 b.</p>\n  \n  <p>tupleC (tuple): \n      the elementwise commutator of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "parameters": ["self", "a", "tupleA", "b", "tupleB"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.multiplyLinCombRound", "modulename": "CQS.methods", "qualname": "FindParameters.multiplyLinCombRound", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms, and rounds things that are smaller than accur to zero.</p>\n", "parameters": ["self", "A", "tuplesA", "B", "tuplesB", "accur"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.printResult", "modulename": "CQS.methods", "qualname": "FindParameters.printResult", "type": "function", "doc": "<p>Prints out the results of the otpimization</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "CQS.methods.FindParameters.saveKH", "modulename": "CQS.methods", "qualname": "FindParameters.saveKH", "type": "function", "doc": "<p>Saves the information about the otimization to a .csv file</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "CQS.util", "modulename": "CQS.util", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.util.IO", "modulename": "CQS.util.IO", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.util.IO.printlist", "modulename": "CQS.util.IO", "qualname": "printlist", "type": "function", "doc": "<p>Function to Print from Tuple format to string format Pauli Strings</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tuples (List of Tuples):</strong>  List of (pauliStrings) to Convert to text</li>\n</ul>\n", "parameters": ["tuples"], "funcdef": "def"}, {"fullname": "CQS.util.IO.paulilabel", "modulename": "CQS.util.IO", "qualname": "paulilabel", "type": "function", "doc": "<p>Transforms numbers in tuples to Pauli terms</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>p (Tuple):</strong>  The (PauliString) input</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>String: 'PauliString'</p>\n</blockquote>\n", "parameters": ["p"], "funcdef": "def"}, {"fullname": "CQS.util.IO.tuplesToMatrix", "modulename": "CQS.util.IO", "qualname": "tuplesToMatrix", "type": "function", "doc": "<p>Converts a Pauli String represented as a Tuple to a matrix element that can be operated on traditionally. Generally expensive to operate with</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>coefficient (np.Complex128):</strong>  Multiplies the resultant matrix</li>\n<li>PauliTuple (Tuple)\nPauli Tuple of the form (0, 1, 2, 3) == IXYZ == kron(kron(kron(I, X), Y), Z)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>ndarray, equal to the kronecker product of the Pauli elements, multiplied by the coefficients</p>\n</blockquote>\n", "parameters": ["coefficient", "PauliTuple"], "funcdef": "def"}, {"fullname": "CQS.util.PauliOps", "modulename": "CQS.util.PauliOps", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.util.PauliOps.ops", "modulename": "CQS.util.PauliOps", "qualname": "ops", "type": "variable", "doc": "<p>Indices for converting from (PauliString) --> String format</p>\n"}, {"fullname": "CQS.util.PauliOps.RULES", "modulename": "CQS.util.PauliOps", "qualname": "RULES", "type": "variable", "doc": "<p>Used for generating the Commutator tables and pauli commutators (efficiently we think)\n``</p>\n\n<h6 id=\"rules\">RULES</h6>\n\n<blockquote>\n  <p>Used to find the multiplication between two paulis represented as indices in a tuple (I == 0, X == 1, Y == 2, Z == 3)</p>\n</blockquote>\n\n<p>The operation is (index1 + index2*RULES[index1] % 4) = Pauli Matrix result as an index</p>\n\n<p>I * anything: 0 + (Index2)<em>1 = index2\nX * anythong: (1 + (Index2)</em>3 % 4) gives\n                                         1 + 0 = 1 for I, \n                                         (1 + 1<em>3) % 4 = 0 for X\n                                         (1 + 2</em>3) % 4 = 7 % 4 = 3 for Y\n                                         (1 + 3*3) % 4 = 10 % 4 = 2 for Z as index2\nThese can easily be expanded for Y and Z\n``</p>\n"}, {"fullname": "CQS.util.PauliOps.SIGN_RULES", "modulename": "CQS.util.PauliOps", "qualname": "SIGN_RULES", "type": "variable", "doc": "<p>Rules for computing the sign of two commutators</p>\n\n<pre><code>SIGN_RULES: \n    Gives the multiplication sign rules for multiplying Pauli Matricies (ex. X*Y -&gt; iZ)\n\n  I  X  Y  Z\nI +  +  +  +\nX +  +  +i -i\nY +  -i +  +i\nZ +  +i -i +\n\nOrder: row * column\n</code></pre>\n"}, {"fullname": "CQS.util.PauliOps.commutatePauliString", "modulename": "CQS.util.PauliOps", "qualname": "commutatePauliString", "type": "function", "doc": "<p>Computes the commutator of two Pauli Strings representated as a tuple</p>\n\n<p>If a commutator table is passed, the operation is much more efficient</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple, integer):</strong>   tuple represenation of the first Pauli String, or the index in the commutator table</li>\n<li><strong>b (np.complex128):</strong>   The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (tuple, int):</strong>   tuple represenation of the second Pauli String, or the index in the commutator table</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result [a<em>TupleA,b</em>TupleB] = c*TupleC, where c is the Structure Constant * a * b\n  tupleC (tuple): \n      the elementwise commutator of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "parameters": ["a", "tupleA", "b", "tupleB", "comm_coefs", "comm_table"], "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.multiplyPauliString", "modulename": "CQS.util.PauliOps", "qualname": "multiplyPauliString", "type": "function", "doc": "<p>Computes the multiplication of two Pauli Strings representated as a tuple</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple):</strong>  tuple represenation of the first Pauli String</li>\n<li><strong>b (np.complex128):</strong>  The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (Tuple):</strong>   tuple represenation of the second Pauli String</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result a<em>TupleA . b</em>TupleB = c*TupleC, where c (the sign of the product of Paulis * a * b)\n  tupleC (tuple) :\n      the elementwise product of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "parameters": ["a", "tupleA", "b", "tupleB"], "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.multiplyLinComb", "modulename": "CQS.util.PauliOps", "qualname": "multiplyLinComb", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms</p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB"], "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.simplifyLinComb", "modulename": "CQS.util.PauliOps", "qualname": "simplifyLinComb", "type": "function", "doc": "<p>Modifies the input lists</p>\n\n<p>Simplifies lin comb of Pauli matrices that it eats. Doens't return anything</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>A:</strong>  A list</li>\n<li><strong>tuples:</strong>  A list</li>\n</ul>\n", "parameters": ["A", "tuples"], "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.commutateLinComb", "modulename": "CQS.util.PauliOps", "qualname": "commutateLinComb", "type": "function", "doc": "<p></p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB", "accur"], "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.multiplyLinCombRound", "modulename": "CQS.util.PauliOps", "qualname": "multiplyLinCombRound", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms, and rounds things that are smaller than accur to zero.</p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB", "accur"], "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.commutateLinCombWithoutFactorOf2", "modulename": "CQS.util.PauliOps", "qualname": "commutateLinCombWithoutFactorOf2", "type": "function", "doc": "<p></p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB", "accur"], "funcdef": "def"}, {"fullname": "CQS.util.PauliOps.cleancoefs", "modulename": "CQS.util.PauliOps", "qualname": "cleancoefs", "type": "function", "doc": "<p>Rounds coefficients that are smaller than accur to zero.</p>\n", "parameters": ["coefs", "accur"], "funcdef": "def"}, {"fullname": "CQS.util.verification", "modulename": "CQS.util.verification", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "CQS.util.verification.Nident", "modulename": "CQS.util.verification", "qualname": "Nident", "type": "function", "doc": "<p>Generates an N qubit Identity Matrix</p>\n", "parameters": ["N"], "funcdef": "def"}, {"fullname": "CQS.util.verification.PauliExpUnitary", "modulename": "CQS.util.verification", "qualname": "PauliExpUnitary", "type": "function", "doc": "<p>Generates the Unitary Matrix for a Pauli Exponential\nUses e^{i.co.Pauli} = I<em>cos(a) + i</em>sin(a)*Pauli</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>N (int):</strong>  Number of qubits</li>\n<li><strong>co (float):</strong>  The coefficient of the Pauli Matrix</li>\n<li><strong>PauliTuple (Tuple):</strong>  (PauliString) to exp</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The result e<sup>i\u2022co\u2022PauliTuple</sup> = I\u2022cos(co) + i\u2022sin(co)\u2022PauliTuple</p>\n</blockquote>\n", "parameters": ["N", "co", "PauliTuple"], "funcdef": "def"}, {"fullname": "CQS.util.verification.exactU", "modulename": "CQS.util.verification", "qualname": "exactU", "type": "function", "doc": "<p>Computes the exact matrix exponential for time evolution at the time t</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>HCos (List of complex numbers):</strong> </li>\n<li><strong>HTupes (List of (PauliStrings)):</strong> </li>\n<li><strong>time (float - time evolution final time):</strong> </li>\n</ul>\n", "parameters": ["HCos", "HTups", "time"], "funcdef": "def"}, {"fullname": "CQS.util.verification.Trotter", "modulename": "CQS.util.verification", "qualname": "Trotter", "type": "function", "doc": "<p>Prepares U_t, the Trotterized input U</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>ham (List of Tuples):</strong>  Hamiltonian formatted as (co, (PauliString))</li>\n<li><strong>time (float):</strong>  final time to evolve to</li>\n<li><strong>N (int):</strong>  number of qubits</li>\n<li><strong>steps (int):</strong>  Number of trotter steps to take</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The U<sub>trotter</sub>(t) that approximates U<sub>exact</sub>(t)</p>\n</blockquote>\n", "parameters": ["ham", "time", "N", "steps"], "funcdef": "def"}, {"fullname": "CQS.util.verification.KHK", "modulename": "CQS.util.verification", "qualname": "KHK", "type": "function", "doc": "<p>Defines the Unitary for the KHK<sup>\u2020</sup>]</p>\n\n<p>Specifically, performs \u213f<sub>i</sub> e<sup>i\u2022k[l]\u2022kCoefs[l]</sup> \u213f<sub>j</sub> e<sup>i\u2022h[j]\u2022hCoefs[j]</sup>  \u213f<sub>l</sub> e<sup>i\u2022k[(lenK - l)]\u2022kCoefs[(lenK - l)]</sup> </p>\n\n<p>Multiply by t before passing the coefficients for h. Do not multiply h by i, that is automatic. The coefficients should be real for k, imaginary for h</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>kCoefs (List):</strong>  A list of (real) coefficients for k</li>\n<li><strong>hCoefs (List):</strong>  The list of (imaginary) coefficients for the elements in h. </li>\n<li><strong>k (List of Tuples):</strong>  The list of (PauliStrings)</li>\n<li><strong>h (List of Tuples):</strong>  List of (PauliStrings) for h (in the same indexing)</li>\n</ul>\n", "parameters": ["kCoefs", "hCoefs", "k", "h"], "funcdef": "def"}]