[{"fullname": "src", "modulename": "src", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "src.CartanMethods", "modulename": "src.CartanMethods", "qualname": "", "type": "module", "doc": "<p>Created on Mon Dec 21 15:19:18 2020</p>\n\n<p>A collection of method to calculate Useful Cartan Methods</p>\n\n<p>@author: Thomas Steckmann\n@author: Efekan Kokcu</p>\n"}, {"fullname": "src.CartanMethods.included", "modulename": "src.CartanMethods", "qualname": "included", "type": "function", "doc": "<p>Following function returns 0 if tuple m is not incu=luded in tuple list g, returns 1 if it is included.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>g (List of Tuples):</strong>   The List of Pauli string elements in the Hamiltonian Algebra \ud835\udd8c(H)</li>\n<li><strong>m (Tuple of 0,1,2,3):</strong>  Pauli string in the set \ud835\udd92</li>\n</ul>\n\n<p>Returns: \n    1 if m is in g\n    0 if not</p>\n", "parameters": ["g", "m"], "funcdef": "def"}, {"fullname": "src.CartanMethods.makeGroup", "modulename": "src.CartanMethods", "qualname": "makeGroup", "type": "function", "doc": "<p>Following function returns a closure of a given list of pauli strings (g). The list doesn't include any coefficients, it is just\na tuple like (0,2,3) representing IYZ.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>g (List of Tuples):</strong>  A set of Pauli Strings</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>g(H), the Hamiltonian Algebra generated by the input g</p>\n</blockquote>\n", "parameters": ["g"], "funcdef": "def"}, {"fullname": "src.CartanMethods.evenOdd", "modulename": "src.CartanMethods", "qualname": "evenOdd", "type": "function", "doc": "<p>Partitions the Algebra by counting the number of non-idenity Pauli elements</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>g (List of Tuples):</strong>  The Algebra to partition</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>k (List of Tuples):\n      The List of Pauli Strings with Odd non-identity terms\n  m (List of Tuples):\n      The List of Pauli Strings with Even non-idenity terms</p>\n</blockquote>\n", "parameters": ["g"], "funcdef": "def"}, {"fullname": "src.CartanMethods.elemcount", "modulename": "src.CartanMethods", "qualname": "elemcount", "type": "function", "doc": "<p></p>\n", "parameters": ["g", "element"], "funcdef": "def"}, {"fullname": "src.CartanMethods.knejaGlaser", "modulename": "src.CartanMethods", "qualname": "knejaGlaser", "type": "function", "doc": "<p>Following one is the Kneja Glaser decomposition. \nIt corresponds to   heta(g) = III...IZ g III..IZ</p>\n", "parameters": ["g", "element"], "funcdef": "def"}, {"fullname": "src.CartanMethods.furtherdecompose", "modulename": "src.CartanMethods", "qualname": "furtherdecompose", "type": "function", "doc": "<p></p>\n", "parameters": ["k"], "funcdef": "def"}, {"fullname": "src.CartanMethods.createK", "modulename": "src.CartanMethods", "qualname": "createK", "type": "function", "doc": "<p>Used to format the output as ex. kh'khkh'k</p>\n\n<p>Not Currently in use</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>abeliank:</strong>  List of Tuples \nFully decomposed k elements</li>\n<li><strong>hlist:</strong>  List of lists of Tuples\nOne for each level of decomposition</li>\n</ul>\n", "parameters": ["abeliank", "hlist"], "funcdef": "def"}, {"fullname": "src.CartanMethods.decomposeToCommuting", "modulename": "src.CartanMethods", "qualname": "decomposeToCommuting", "type": "function", "doc": "<p>Decomposed untill it reaches an Abelian k, and returns a list that is ready to be put into the 'k' parameter in funky.</p>\n\n<p>Not Currently in use. Instead, train optimizer on Sequence of Exponentials: e^k0 @ e^k1 instead of e^(k0 + k1)</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>k (List of Tuples):</strong>  K subalgebra</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tuple List [k',h',k'], Where each is a list of Tuples\n  or [k'',h'',k'',h',k'',h'',k''], etc.</p>\n</blockquote>\n", "parameters": ["k"], "funcdef": "def"}, {"fullname": "src.CartanMethods.getsubalgebra", "modulename": "src.CartanMethods", "qualname": "getsubalgebra", "type": "function", "doc": "<p>Starts with an empty list, every element that commutes with the first element of H</p>\n", "parameters": ["m"], "funcdef": "def"}, {"fullname": "src.CartanMethods.getsubalgebraelem", "modulename": "src.CartanMethods", "qualname": "getsubalgebraelem", "type": "function", "doc": "<p>Takes an imput \"seed\" element, find all the elements that commute</p>\n", "parameters": ["m", "elemlist"], "funcdef": "def"}, {"fullname": "src.EarpPachosInnerProduct", "modulename": "src.EarpPachosInnerProduct", "qualname": "", "type": "module", "doc": "<p>Created on Mon Dec 21 14:45:19 2020\nMethod to minimize in order to find the coefficients in the Cartan Decomposition</p>\n\n<p>Two Sections:\n    EarpPachosInnerProduct: Find a local minimum of <v, Ad_K(H)&gt;, where v is a dense vector in h\n@author: Efekan Kokcu</p>\n"}, {"fullname": "src.HamiltonianAlgebra", "modulename": "src.HamiltonianAlgebra", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "src.HamiltonianAlgebra.generateAlgebra", "modulename": "src.HamiltonianAlgebra", "qualname": "generateAlgebra", "type": "function", "doc": "<p>Provided the model parameters, generates the Hamiltonian and the decomposition elements</p>\n\n<p>Currently Implemented Models:</p>\n\n<ul>\n<li>XY: (XX + YY)</li>\n<li>XX: (XXI + IXX)</li>\n<li>YY: (YYI + IYY)</li>\n<li>ZZ: (ZZI + IZZ)</li>\n<li>Transverse_Z: (IZ + ZI)</li>\n<li>KitaevEven: (XXI + IYY)</li>\n<li>KitaevOdd: (YYI + IXX)</li>\n<li>TransverseIsing: (XX + IZ + ZI)</li>\n<li>Heisenberg: (XX + YY + ZZ)</li>\n</ul>\n\n<p>Generates the Hamiltonian, a Cartan Decomposition, and the Pauli String algebraic elements</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>sites (int):</strong>   Number of qubits to use (lattice points)</li>\n<li><p><strong>modelType (Tuple of Strings):</strong>   Format: ('modelNameOne','modelNameTwo', ...). </p>\n\n<p>For a single model, use: ('modelNameOne',)\n   Currently Implemented Models:</p>\n\n<ul>\n<li>'XY'</li>\n<li>'XX' </li>\n<li>'YY'</li>\n<li>'ZZ' </li>\n<li>'Transverse_Z' </li>\n<li>'KitaevEven' </li>\n<li>'KitaevOdd' </li>\n<li>'TransverseIsing' </li>\n<li>'Heisenberg'</li>\n<li>[(List of Pauli String Tuples)]: Must include (),manualMode=True) to use. Pauli String List formatted as H = XZYI + XXZZ written as [(1,3,2,0),(1,1,3,3)]</li>\n</ul></li>\n<li><p><strong>J (Tuple of floats):</strong>   The Coupling constants.</p>\n\n<p>Two Possible Formats:</p>\n\n<ul>\n<li><code>(1,1)</code>: Two models, each with coefficient 1 on each term</li>\n<li><code>([1,0.9,0.8,...],[...])</code>: Two models, with coefficients ordered for each term</li>\n</ul></li>\n<li><p><strong>closed (Bool):</strong>  True if the model has periodic boundary condistions\nreturnAlg (bool, optional): \nTrue if the return should be formatted as a list of Tuples formatted as: <code>[(1, (1,1,0,0)), ...]</code> would be <code>H = 1*XXII</code></p>\n\n<p>Default: Return the Coefficients as a vector indexed by the terms in the h algebra + the m / h algebra</p>\n\n<p>returnAlg = True should be used with the EarpPachosInnerProduct method</p></li>\n<li><strong>manualMode (bool, optional):</strong>  Allows for explicit input of a not implemented Hamiltonian</li>\n</ul>\n", "parameters": ["sites", "modelType", "J", "closed", "returnAlg", "manualMode"], "funcdef": "def"}, {"fullname": "src.HamiltonianAlgebra.hamiltonianTuples", "modulename": "src.HamiltonianAlgebra", "qualname": "hamiltonianTuples", "type": "function", "doc": "<p>Helper Function for generateAlgebra.</p>\n\n<p>From the sites and model type, generates the Hamiltonian Pauli Strings</p>\n\n<p>Args: \n    sites (int): \n        Number of qubits in the system or lattice points.\n    modelType (Tuple of Strings): \n        See generateAlgebra for formatting.\n    closed (bool): \n        True if the model is period.</p>\n", "parameters": ["sites", "modelType", "closed"], "funcdef": "def"}, {"fullname": "src.IO", "modulename": "src.IO", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "src.IO.printlist", "modulename": "src.IO", "qualname": "printlist", "type": "function", "doc": "<p>Function to Print from Tuple format to string format Pauli Strings</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tuples (List of Tuples):</strong>  List of Pauli Strings to Convert to text</li>\n</ul>\n", "parameters": ["tuples"], "funcdef": "def"}, {"fullname": "src.IO.tuplesToMatrix", "modulename": "src.IO", "qualname": "tuplesToMatrix", "type": "function", "doc": "<p>Converts a Pauli String represented as a Tuple to a matrix element that can be operated on traditionally. Generally expensive to operate with</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>coefficient (np.Complex128):</strong>  Multiplies the resultant matrix</li>\n<li>PauliTuple (Tuple)\nPauli Tuple of the form (0, 1, 2, 3) == IXYZ == kron(kron(kron(I, X), Y), Z)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>ndarray, equal to the kronecker product of the Pauli elements, multiplied by the coefficients</p>\n</blockquote>\n", "parameters": ["coefficient", "PauliTuple"], "funcdef": "def"}, {"fullname": "src.MinimizerFunctions", "modulename": "src.MinimizerFunctions", "qualname": "", "type": "module", "doc": "<p>Created on Mon Dec 21 14:45:19 2020\nMethods to minimize in order to find the coefficients in the Cartan Decomposition</p>\n\n<p>Two Sections:\n    AdjointRepNorm: Find the zero of |Ad_k(h) - H |, and optimizes over coefficients for k and h\n    AdjointInnerProduct: Find a local minimum of <v, Ad_K(H)&gt;, where v is a dense vector in h\n@author: Thomas Steckmann\n@author: Efekan Kokcu</p>\n"}, {"fullname": "src.MinimizerFunctions.adjointRepNorm", "modulename": "src.MinimizerFunctions", "qualname": "adjointRepNorm", "type": "function", "doc": "<p></p>\n", "parameters": ["initialGuess", "args"], "funcdef": "def"}, {"fullname": "src.MinimizerFunctions.adjointAction", "modulename": "src.MinimizerFunctions", "qualname": "adjointAction", "type": "function", "doc": "<p></p>\n", "parameters": ["hmTupleList", "kTupleList", "kVector"], "funcdef": "def"}, {"fullname": "src.MinimizerFunctions.adjointRep", "modulename": "src.MinimizerFunctions", "qualname": "adjointRep", "type": "function", "doc": "<p></p>\n", "parameters": ["depth", "ad", "hGuess", "lenhm"], "funcdef": "def"}, {"fullname": "src.Optimizer", "modulename": "src.Optimizer", "qualname": "", "type": "module", "doc": "<p>Created on Mon Dec 21 14:14:40 2020</p>\n\n<p>General Methods to compute the exponential coefficients in the Cartan Decomposition of a 1D spin lattice hamiltonian</p>\n\n<p>Depends on:\n    - MinimizerFunctions.py\n        - adjointRepNorm\n        - adjointAction\n        - ajointInnerProduct\n        - generalInnerProduct\n        - gradAdjointInnerProduct\n        - gethVecFromk</p>\n\n<pre><code>- HamiltonianAlgebra.py\n    - generateAlgebra\n    - hamiltonianTuple\n    - \n\n- CartanMethods.py\n    - MakeGroup (Hamiltonian)\n    - findh(m)\n    - getSubalgebra(m)\n    - getSubalgebraElem(m,element)\n\n- PauliOps.py\n    - commutePauliString\n    - multiplyPauliString\n    - multiplyLinComb\n    - simplifyLinComb\n\n- IO.py\n    - saveCSV\n    - printList\n</code></pre>\n\n<p>@author: Thomas Steckmann\n@author: Efekan Kokcu</p>\n"}, {"fullname": "src.Optimizer.FindParameters", "modulename": "src.Optimizer", "qualname": "FindParameters", "type": "function", "doc": "<p>Hopefully the only function you will need to use. </p>\n\n<p>Takes all the parameters of your model and output options and produces the Gates and gate angles</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li>ModelType (tuple of Strings)\nValid models include: \n   'X',\n   'Y',\n   'Z',\n   'XY',\n   'XY2D',\n   'KitaevEven',\n   'KitaevOdd',\n   'Heisenberg',\n   TransverseIsing',\n   'Transverse_Z'\nModels can be combined to get different coupling, such as Jx = 0.5 and Jy= 1 being described as ('X','Y')</li>\n<li><strong>J (tuple of Floats OR Lists of Floats):</strong>  Depending on the model type, J is either a tuple for coupling corresponding to the same index model,\nor it is a tuple of tuples with one coupling for each intereaction in the Hamiltonian. Each J is shared by site \nfor the specificed Hamiltonian                              </li>\n<li><strong>closed (bool):</strong>  True if Periodic Boundary conditions</li>\n<li><strong>fileName (String):</strong> <br />\nDetermines the read/write file location, if such behavior is desired</li>\n<li><strong>sites (int):</strong>  3 - 8 (No hard maximum, just runtime)</li>\n<li><strong>depth (int):</strong>  10\nThe number of terms in the BCH lemma expansion of Adjoint Representation\nNot needed for EarpPachosInnerProduct</li>\n<li><strong>acc (float):</strong>  Determines the convergence criteria</li>\n<li><strong>options (dict)::</strong>  {\n'evolve': string                                                                          #######Not yet implemented###########\n   Choose the path of the optimizer. Default is to use the guess of 1 for all h elements and 0 for all k elements\n   Evolving the Hamiltonian to turn on coupling might be faster or might produce more consistent results. \n   options:\n       None\n       'nextTerm'\n       'split',\n'ordered': True,\n'return': Tuple of strings\n   Determines the output method. Options include:\n       'python'\n       'plot'\n       'mathemtica' <br />\n       'csv',\n'debug': bool\n   Print details about the optimization, such as the hamiltonian, algebra, and convergence, <br />\n'steps': int\n   The Maximum number of iterations or steps in the optimizer,\n'statusReporter': bool\n   If True, the program will print progress messages to console\n'loadFile': bool <br />\n'method': string <br />\n   Determines the method of minimization\n   Options include\n       'AdjointRep'\n       'AdjointInnerProduct',\n'optimizerFunction': string\n   The minimizer function to be used. Defaults to Powell for AdjointRep, BFGS for AdjointInnerProduct. Easy to add more options\n   Options:\n       'Powell'\n       'BFGS',\n}</li>\n</ul>\n\n<h6 id=\"todo\">Todo</h6>\n\n<blockquote>\n  <ul>\n  <li>Fix Status Reporter</li>\n  <li>File Loading</li>\n  <li>Evolve Optimization Path (Turn on coupling slowly)</li>\n  <li>File Name Behavior</li>\n  <li>Cartan Subalgebra Choices</li>\n  <li>EarpPachosInnerProduct Methods</li>\n  </ul>\n</blockquote>\n", "parameters": ["modelType", "J", "sites", "closed", "fileName", "depth", "acc", "options"], "funcdef": "def"}, {"fullname": "src.PauliOps", "modulename": "src.PauliOps", "qualname": "", "type": "module", "doc": "<p>Created on Mon Dec 21 15:16:56 2020\nA Collection of Methods to calcualte useful operations on Pauli Strings</p>\n\n<p>@author: Thomas Steckmann\n@author: Efekan Kokcu</p>\n"}, {"fullname": "src.PauliOps.ops", "modulename": "src.PauliOps", "qualname": "ops", "type": "variable", "doc": "<h6 id=\"rules\">RULES</h6>\n\n<blockquote>\n  <p>Used to find the multiplication between two paulis represented as indices in a tuple (I == 0, X == 1, Y == 2, Z == 3)</p>\n</blockquote>\n\n<p>The operation is (index1 + index2*RULES[index1] % 4) = Pauli Matrix result as an index</p>\n\n<p>I * anything: 0 + (Index2)<em>1 = index2\nX * anythong: (1 + (Index2)</em>3 % 4) gives\n                                         1 + 0 = 1 for I, \n                                         (1 + 1<em>3) % 4 = 0 for X\n                                         (1 + 2</em>3) % 4 = 7 % 4 = 3 for Y\n                                         (1 + 3*3) % 4 = 10 % 4 = 2 for Z as index2\nThese can easily be expanded for Y and Z</p>\n"}, {"fullname": "src.PauliOps.RULES", "modulename": "src.PauliOps", "qualname": "RULES", "type": "variable", "doc": "<p>SIGN_RULES: \n    Gives the multiplication sign rules for multiplying Pauli Matricies (ex. X*Y -> iZ)</p>\n\n<p>I  X  Y  Z\nI +  +  +  +\nX +  +  +i -i\nY +  -i +  +i\nZ +  +i -i +</p>\n\n<p>Order: row * column</p>\n"}, {"fullname": "src.PauliOps.set_tuples", "modulename": "src.PauliOps", "qualname": "set_tuples", "type": "function", "doc": "<p>Sets the global tuples up there and generates commutation table, so that we wouldn't have to calculate their commutation again and again.</p>\n", "parameters": ["k", "m", "h"], "funcdef": "def"}, {"fullname": "src.PauliOps.commutatePauliString", "modulename": "src.PauliOps", "qualname": "commutatePauliString", "type": "function", "doc": "<p>Computes the commutator of two Pauli Strings representated as a tuple</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple):</strong>   tuple represenation of the first Pauli String</li>\n<li><strong>b (np.complex128):</strong>   The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (tuple):</strong>   tuple represenation of the second Pauli String</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result [a<em>TupleA,b</em>TupleB] = c*TupleC, where c is the Structure Constant * a * b\n  tupleC (tuple): \n      the elementwise commutator of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "parameters": ["a", "tupleA", "b", "tupleB"], "funcdef": "def"}, {"fullname": "src.PauliOps.multiplyPauliString", "modulename": "src.PauliOps", "qualname": "multiplyPauliString", "type": "function", "doc": "<p>Computes the multiplication of two Pauli Strings representated as a tuple</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple):</strong>  tuple represenation of the first Pauli String</li>\n<li><strong>b (np.complex128):</strong>  The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (Tuple):</strong>   tuple represenation of the second Pauli String</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result a<em>TupleA . b</em>TupleB = c*TupleC, where c (the sign of the product of Paulis * a * b)\n  tupleC (tuple) :\n      the elementwise product of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "parameters": ["a", "tupleA", "b", "tupleB"], "funcdef": "def"}, {"fullname": "src.PauliOps.multiplyLinComb", "modulename": "src.PauliOps", "qualname": "multiplyLinComb", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms</p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB"], "funcdef": "def"}, {"fullname": "src.PauliOps.simplifyLinComb", "modulename": "src.PauliOps", "qualname": "simplifyLinComb", "type": "function", "doc": "<p>Modifies the input lists</p>\n\n<p>Simplifies lin comb of Pauli matrices that it eats. Doens't return anything</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>A:</strong>  A list</li>\n<li><strong>tuples:</strong>  A list</li>\n</ul>\n", "parameters": ["A", "tuples"], "funcdef": "def"}, {"fullname": "src.PauliOps.commutateLinComb", "modulename": "src.PauliOps", "qualname": "commutateLinComb", "type": "function", "doc": "<p></p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB", "accur"], "funcdef": "def"}, {"fullname": "src.PauliOps.commutateLinCombWithoutFactorOf2", "modulename": "src.PauliOps", "qualname": "commutateLinCombWithoutFactorOf2", "type": "function", "doc": "<p></p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB", "accur"], "funcdef": "def"}, {"fullname": "src.PauliOps.cleancoefs", "modulename": "src.PauliOps", "qualname": "cleancoefs", "type": "function", "doc": "<p>Rounds coefficients that are smaller than accur to zero.</p>\n", "parameters": ["coefs", "accur"], "funcdef": "def"}]