[{"fullname": "package", "modulename": "package", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "package.src", "modulename": "package.src", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "package.src.Cartan", "modulename": "package.src.Cartan", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "package.src.Cartan.Cartan", "modulename": "package.src.Cartan", "qualname": "Cartan", "type": "class", "doc": "<p>Class to contain the options for performing Cartan Decomposition on a Hamiltonian</p>\n\n<p>Functionality:</p>\n\n<ul>\n<li>Generate Hamiltonian Algebra</li>\n<li>Generate k, m, h partition</li>\n<li>Choose involution (Default - Even/Odd)</li>\n<li>Seed choice of h</li>\n<li>Modify k (Additional Decomposition, TODO: Abelian Decomposition, Piling)</li>\n</ul>\n"}, {"fullname": "package.src.Cartan.Cartan.__init__", "modulename": "package.src.Cartan", "qualname": "Cartan.__init__", "type": "function", "doc": "<p>Generates the Cartan Object</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>hamObj (Hamiltonian):</strong>  Passes a Hamiltonian Object containing the full information about the system</li>\n<li><p><strong>involution (String, default='evenOdd'):</strong>  Allows a choice of the k,m involuiton</p>\n\n<p>Options:</p>\n\n<ul>\n<li><code>'evenOdd'</code>: m contains an even number of non-identity pauli terms in each string, k contains an odd nunber of non-idenity elements</li>\n<li><code>'knejaGlaser'</code>: m contains elements ending in Y or X, k contains elements ending in I or Z</li>\n<li><code>'count' + 'X', 'Y', or 'Z'</code>: Counts of the number of the specified Pauli Tuple. Even count in m, odd in k</li>\n</ul></li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>hamiltonian (::hamiltonian:: object):</strong>  Allows access to HCoefficients and HTuples</li>\n<li><strong>HTuples (List of Tuples):</strong>  Copies over the HTuples from the hamiltonian object</li>\n<li><strong>g (List of Tuples):</strong>  Generates formatted like k + h + (m without h)</li>\n<li><strong>k (List of Tuples):</strong>  Specified by the decomposition. Changing k regenerates h and the order of g (g = k + h + (m\\h))</li>\n<li><strong>h (List of Tuples):</strong>  Specified by SubAlgebra(). Defaults to seeding by m, otherwise allows for inclusion of specific elements</li>\n</ul>\n", "parameters": ["self", "hamObj", "involution"], "funcdef": "def"}, {"fullname": "package.src.Cartan.Cartan.decompose", "modulename": "package.src.Cartan", "qualname": "Cartan.decompose", "type": "function", "doc": "<p>Sets a new Involution using a switch. Regenerates h using the default first element in m</p>\n", "parameters": ["self", "involutionName"], "funcdef": "def"}, {"fullname": "package.src.Cartan.Cartan.makeGroup", "modulename": "package.src.Cartan", "qualname": "Cartan.makeGroup", "type": "function", "doc": "<p>Returns a closure of a given list of pauli strings (g). The list doesn't include any coefficients, it is just\na tuple like (0,2,3) representing IYZ.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>g (List of Tuples):</strong>  A set of Pauli Strings</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>List of Tuples: \ud835\udd8c(H), the Hamiltonian Algebra generated by the input g</p>\n</blockquote>\n", "parameters": ["self", "g"], "funcdef": "def"}, {"fullname": "package.src.Cartan.Cartan.elemcount", "modulename": "package.src.Cartan", "qualname": "Cartan.elemcount", "type": "function", "doc": "<p>Counts the number of given elements (X,Y or Z in number), and puts even numbers in m, odd numbers in k. \nFor element=2, it corresponds to \u03b8(g) = -g^T</p>\n", "parameters": ["self", "g", "element"], "funcdef": "def"}, {"fullname": "package.src.Cartan.Cartan.included", "modulename": "package.src.Cartan", "qualname": "Cartan.included", "type": "function", "doc": "<p>Following function returns 0 if tuple m is not incu=luded in tuple list g, returns 1 if it is included.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>g (List of Tuples):</strong>   The List of Pauli string elements in the Hamiltonian Algebra \ud835\udd8c(H)</li>\n<li><strong>m (Tuple of 0,1,2,3):</strong>  Pauli string in the set \ud835\udd92</li>\n</ul>\n\n<p>Returns: \n    1 if m is in g\n    0 if not</p>\n", "parameters": ["self", "g", "m"], "funcdef": "def"}, {"fullname": "package.src.Cartan.Cartan.evenOdd", "modulename": "package.src.Cartan", "qualname": "Cartan.evenOdd", "type": "function", "doc": "<p>Partitions the Algebra by counting the number of non-idenity Pauli elements</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>g (List of Tuples):</strong>  The Algebra to partition</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>k (List of Tuples):\n      The List of Pauli Strings with Odd non-identity terms\n  m (List of Tuples):\n      The List of Pauli Strings with Even non-idenity terms</p>\n</blockquote>\n", "parameters": ["self", "g"], "funcdef": "def"}, {"fullname": "package.src.Cartan.Cartan.knejaGlaser", "modulename": "package.src.Cartan", "qualname": "Cartan.knejaGlaser", "type": "function", "doc": "<p>Following one is the Kneja Glaser decomposition. \nIt corresponds to       heta(g) = III...IZ g III..IZ</p>\n", "parameters": ["self", "g"], "funcdef": "def"}, {"fullname": "package.src.Cartan.Cartan.subAlgebra", "modulename": "package.src.Cartan", "qualname": "Cartan.subAlgebra", "type": "function", "doc": "<p>Generates h from a list of Commuting elements in the seedList </p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>seedList (List of Tuples):</strong>  List of (PauliStrings). Must be commuting</li>\n</ul>\n\n<h6 id=\"todo\">TODO</h6>\n\n<blockquote>\n  <p>Verify that seedList is commuting</p>\n</blockquote>\n", "parameters": ["self", "seedList"], "funcdef": "def"}, {"fullname": "package.src.FindParameters", "modulename": "package.src.FindParameters", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "package.src.FindParameters.FindParameters", "modulename": "package.src.FindParameters", "qualname": "FindParameters", "type": "class", "doc": "<p>Class to find, manage, and store information about the parameters needed in the decomposition</p>\n"}, {"fullname": "package.src.FindParameters.FindParameters.__init__", "modulename": "package.src.FindParameters", "qualname": "FindParameters.__init__", "type": "function", "doc": "<p>Initializing a FindParameters class automatically runs the optimizer over the Cartan decomposition and provided Hamiltonian</p>\n\n<p>If saveFileName is provided, verifies file location before proceeding, and saves the output as a csv\nIf loadFileName is provided, does not run the optimizer and instead reads data from the provided file</p>\n\n<h6 id=\"todo\">TODO</h6>\n\n<blockquote>\n  <ul>\n  <li>Write Load file functions</li>\n  </ul>\n</blockquote>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cartan (Obj Cartan):</strong>  The Cartan object containing the k,h, and Hamiltonian information</li>\n<li><strong>saveFileName (String, default=None):</strong>  path to save the output.</li>\n<li><strong>loadFileName (String, default=None):</strong>  path to a csv containing previous optimizer results</li>\n<li><p><strong>optimizer (String, default='BFGS'):</strong>  The Scipy optimizer to use. Easy to add new ones, but must be done manually</p>\n\n<p>Options: </p>\n\n<ul>\n<li><code>'BFGS'</code> : Uses Gradient</li>\n<li>'<code>Powel'</code>: Does not use Gradient</li>\n</ul></li>\n<li><strong>accuracy (float, default=1e-5):</strong>  Optimizer convergence Criteria</li>\n<li><strong>initialGuess (List of values):</strong>  Allows the user to specify the inital guess for k. Must be correct, no input checking is currently implemented</li>\n<li><strong>steps (int):</strong>  The maximum number of optimization steps before termination</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <ul>\n  <li>Progress updates and runtime predictions</li>\n  <li>prints the results of the optimization</li>\n  </ul>\n</blockquote>\n", "parameters": ["self", "cartan", "saveFileName", "loadfileName", "optimizerMethod", "accuracy", "initialGuess", "steps"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.setCommutatorTables", "modulename": "package.src.FindParameters", "qualname": "FindParameters.setCommutatorTables", "type": "function", "doc": "<p>Generates commutator look-up tables for the commutators of different elements</p>\n\n<p>Important: g must be ordered as k + h + (the rest of m). Does not work without this ordering</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.generateIndexLists", "modulename": "package.src.FindParameters", "qualname": "FindParameters.generateIndexLists", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.optimize", "modulename": "package.src.FindParameters", "qualname": "FindParameters.optimize", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.generalCostFunction", "modulename": "package.src.FindParameters", "qualname": "FindParameters.generalCostFunction", "type": "function", "doc": "<p>This returns Tr(e<sup>i\u2022thetas1\u2022k1</sup>\u2022v\u2022e<sup>-thetas2\u2022k2</sup>\u2022H)\n(To make it clear, for Earp and Pachos function, we have k1=k2=k, thetas1=thetas2=thetas)</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>thetas1 (List):</strong>  The coefficients for the k_tuples on the left side</li>\n<li><strong>thetas2 (List):</strong>  The coefficients for the K_tuples on the right side</li>\n<li><strong>index (int):</strong>  The number of k elements acting on v</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Tr(e<sup>i\u2022thetas1\u2022k1</sup>)\u2022v\u2022e<sup>-thetas2\u2022k2</sup>\u2022H)</p>\n</blockquote>\n\n<p>TODO: \n    * Comment the steps in this section</p>\n", "parameters": ["self", "thetas1", "thetas2", "index"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.CostFunction", "modulename": "package.src.FindParameters", "qualname": "FindParameters.CostFunction", "type": "function", "doc": "<p>returns Tr(exp(thetas\u2022k)\u2022v\u2022exp(-thetas\u2022k)\u2022H)</p>\n", "parameters": ["self", "thetas"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.gradCostFunction", "modulename": "package.src.FindParameters", "qualname": "FindParameters.gradCostFunction", "type": "function", "doc": "<p>returns gradient of funky. Order of derivatives is the order of the parameters thetas.</p>\n", "parameters": ["self", "thetas"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.adj_action", "modulename": "package.src.FindParameters", "qualname": "FindParameters.adj_action", "type": "function", "doc": "<p>Computes Ad<sub>k</sub>(m) = e<sup>i\u2022theta</sup>(coefs \u2022 tuples)e<sup>-i\u2022theta</sup>\nAlso known as the Adjoint Representation</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>theta (float):</strong>  A single value, the coeffient of the k PauilString</li>\n<li><strong>k (Tuple):</strong>  A (PauliString)</li>\n<li><strong>coefs (List of floats, can be complex):</strong>  The coefficients indexed in order of the elements in tuples</li>\n<li><strong>tuples (List of tuples):</strong>  A List of (PauliStrings)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The Algebraic element in m which is the result of the Adjoint Action (Representation)</p>\n</blockquote>\n", "parameters": ["self", "theta", "k", "coefs", "tuples"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.sethVecFromk", "modulename": "package.src.FindParameters", "qualname": "FindParameters.sethVecFromk", "type": "function", "doc": "<p>Returns h = exp(-thetas\u2022k)\u2022H\u2022exp(thetas\u2022k)</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.errorhVec", "modulename": "package.src.FindParameters", "qualname": "FindParameters.errorhVec", "type": "function", "doc": "<p>Gets the norm square of the part in hcoefs\u2022htuples that is orthogonal to Cartan subalgebra h.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.multiplyLinComb", "modulename": "package.src.FindParameters", "qualname": "FindParameters.multiplyLinComb", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms</p>\n", "parameters": ["self", "A", "tuplesA", "B", "tuplesB"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.multiplyPauliString", "modulename": "package.src.FindParameters", "qualname": "FindParameters.multiplyPauliString", "type": "function", "doc": "<p>Computes the multiplication of two Pauli Strings representated as a tuple</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple or index in g):</strong>  tuple represenation of the first Pauli String</li>\n<li><strong>b (np.complex128):</strong>  The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (Tuple or index in g):</strong>   tuple represenation of the second Pauli String</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result a\u2022TupleA . b\u2022TupleB = c\u2022TupleC, where c (the sign of the product of Paulis \u2022 a \u2022 b)\n  tupleC (tuple) :\n      the elementwise product of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "parameters": ["self", "a", "tupleA", "b", "tupleB"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.commutatePauliString", "modulename": "package.src.FindParameters", "qualname": "FindParameters.commutatePauliString", "type": "function", "doc": "<p>Computes the commutator of two Pauli Strings representated as a tuple</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple, integer):</strong>   tuple represenation of the first Pauli String, or the index in the commutator table</li>\n<li><strong>b (np.complex128):</strong>   The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (tuple, int):</strong>   tuple represenation of the second Pauli String, or the index in the commutator table</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result [a\u2022TupleA,b\u2022TupleB] = c\u2022TupleC, where c is the Structure Constant \u2022 a \u2022 b.</p>\n  \n  <p>tupleC (tuple): \n      the elementwise commutator of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "parameters": ["self", "a", "tupleA", "b", "tupleB"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.multiplyLinCombRound", "modulename": "package.src.FindParameters", "qualname": "FindParameters.multiplyLinCombRound", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms, and rounds things that are smaller than accur to zero.</p>\n", "parameters": ["self", "A", "tuplesA", "B", "tuplesB", "accur"], "funcdef": "def"}, {"fullname": "package.src.FindParameters.FindParameters.printResult", "modulename": "package.src.FindParameters", "qualname": "FindParameters.printResult", "type": "function", "doc": "<p>Prints out the results of the otpimization</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "package.src.Hamiltonian", "modulename": "package.src.Hamiltonian", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "package.src.Hamiltonian.Hamiltonian", "modulename": "package.src.Hamiltonian", "qualname": "Hamiltonian", "type": "class", "doc": "<p></p>\n"}, {"fullname": "package.src.Hamiltonian.Hamiltonian.__init__", "modulename": "package.src.Hamiltonian", "qualname": "Hamiltonian.__init__", "type": "function", "doc": "<p>Initializes an emtpy Hamiltnoan, unless name is specified</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>qubits (int):</strong>  The number of lattice points the Hamiltonisn svyd on</li>\n<li><p><strong>name (List of Tuples):</strong>  Easily build Hamiltonians from native models. </p>\n\n<h3 id=\"options\">Options:</h3>\n\n<ul>\n<li><code>[(coefficient, 'modelname', periodic boundary condisitons boolian)]</code> - Builds a single Hamiltonian with constant coefficient. Periodic boundary conditions are true or false, false is assumed if not specified</li>\n<li><code>[([list of coefficients], 'modelname')]</code> - Populates the Hamiltonian using the list of coefficients. Lengths must match</li>\n<li><p><code>[(coefficient, 'modelname1'),([list of coefficients], 'modelname2')]</code> - Combines two Hamiltonains. Order my alter default choice of \ud835\udd8d</p>\n\n<h4 id=\"examples\">Examples:</h4></li>\n<li><p><code>[(1,'XY', true)]</code> on three qubits gives: XXI + YYI + IXX + IYY + XIX + YIY</p></li>\n<li><p>`[([1,2],'kitaevEven')] on three qubits gives: 1<em>XXI + 2</em>IYY </p>\n\n<h3 id=\"currently-implemented-models\">Currently Implemented Models:</h3></li>\n<li><p>xy: (XX + YY)</p></li>\n<li>xx: (XXI + IXX)</li>\n<li>yy: (YYI + IYY)</li>\n<li>zz: (ZZI + IZZ)</li>\n<li>tfim: (ZZ + XI + IX)</li>\n<li>tfxy: (XX + YY + ZI + IZ)</li>\n<li>transverse_z: (IZ + ZI)</li>\n<li>kitaev_even: (XXI + IYY)</li>\n<li>kitaev_odd: (YYI + IXX)</li>\n<li>heisenberg: (XX + YY + ZZ)</li>\n<li>hubbard: (XXII + YYII + IIXX + IIYY + ZIZI + IZIZ)</li>\n</ul></li>\n</ul>\n", "parameters": ["self", "sites", "name"], "funcdef": "def"}, {"fullname": "package.src.Hamiltonian.Hamiltonian.addModel", "modulename": "package.src.Hamiltonian", "qualname": "Hamiltonian.addModel", "type": "function", "doc": "<p>Adds a predefined model to the Hamiltonian object</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>pair (Tuple):</strong>   ### Currently Implemented Models:\n<ul>\n<li>xy: (XX + YY)</li>\n<li>xx: (XXI + IXX)</li>\n<li>yy: (YYI + IYY)</li>\n<li>zz: (ZZI + IZZ)</li>\n<li>tfim: (ZZ + XI + IX)</li>\n<li>tfxy: (XX + YY + ZI + IZ)</li>\n<li>transverse_z: (IZ + ZI)</li>\n<li>kitaev_even: (XXI + IYY)</li>\n<li>kitaev_odd: (YYI + IXX)</li>\n<li>heisenberg: (XX + YY + ZZ)</li>\n<li>hubbard: (XXII + YYII + IIXX + IIYY + ZIZI + IZIZ)</li>\n</ul></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError:</strong>   Coefficient list length mismatch</li>\n<li><strong>Exception:</strong>  Invalid model type input</li>\n</ul>\n", "parameters": ["self", "pair"], "funcdef": "def"}, {"fullname": "package.src.Hamiltonian.Hamiltonian.addTerms", "modulename": "package.src.Hamiltonian", "qualname": "Hamiltonian.addTerms", "type": "function", "doc": "<p>Adds custom elements to build out the Hamiltonian</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>pair (List of Tuples or Tuple of Lists or Tuple):</strong>  Formatted as either\n<ul>\n<li><code>[(coefficient, PauliString), (coefficient, PauliStringTuple),...]</code></li>\n<li><code>(coefficient, (PauliString))</code></li>\n<li>`([coefficienList],[(PauliStringList)])</li>\n</ul></li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<blockquote>\n  <ul>\n  <li><code>Hamiltonian.addTerms((0.45, (1,3,2,0,0,0)))</code></li>\n  <li>`Hamiltonian.addTerms([(1,(1,1,0,0)),(2,(2,2,0,0))])</li>\n  <li>`Hamiltonian.addTerms(([co1, co2, co3, ...],[(PauliString1),(PauliString2),(PauliString3)...])</li>\n  </ul>\n</blockquote>\n", "parameters": ["self", "pairs"], "funcdef": "def"}, {"fullname": "package.src.Hamiltonian.Hamiltonian.generateHamiltonian", "modulename": "package.src.Hamiltonian", "qualname": "Hamiltonian.generateHamiltonian", "type": "function", "doc": "<p>Helper Function to generate Hamiltonians.</p>\n\n<p>From the model type, generates the Hamiltonian Pauli Strings</p>\n\n<p>Args: \n    modelType (Tuple of Strings): \n    closed (bool): \n        True if the model is period.</p>\n", "parameters": ["self", "modelType", "closed"], "funcdef": "def"}, {"fullname": "package.src.Hamiltonian.Hamiltonian.getHamiltonian", "modulename": "package.src.Hamiltonian", "qualname": "Hamiltonian.getHamiltonian", "type": "function", "doc": "<p>Based on the type, returns the Hamiltonian from the object and formats it.\n       Args:\n           type (String, default = 'tuples'): Specifies the return type of the function.\n               Valid inputs::</p>\n\n<pre><code>            - 'tuples': Return formatted as `[(coefficient, (PauliString), ... ]`\n\n            - 'printTuples': Prints out to the console ``(coefficient, (PauliString))\n</code></pre>\n\n<p>...``</p>\n\n<pre><code>            - 'printText': Prints out ``'coefficient * 'PauliString' + ....``\n\n            - 'text': Return formatted as a list of `[[coefficient, 'PauliString']]`\n\n   Returns:\n       For type=`'tuples'` or type=`'text'`, returns\n\n       - `'tuples'`: A list of Coefficient, (PauliString) Tuple pairs\n       - `'text'`: A List of Coefficient 'PauliString' List pairs\n\n   Raises:\n       ValueError: Invalid type\n</code></pre>\n", "parameters": ["self", "type"], "funcdef": "def"}, {"fullname": "package.util", "modulename": "package.util", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "package.util.IO", "modulename": "package.util.IO", "qualname": "", "type": "module", "doc": "<p></p>\n"}, {"fullname": "package.util.IO.printlist", "modulename": "package.util.IO", "qualname": "printlist", "type": "function", "doc": "<p>Function to Print from Tuple format to string format Pauli Strings</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>tuples (List of Tuples):</strong>  List of (pauliStrings) to Convert to text</li>\n</ul>\n", "parameters": ["tuples"], "funcdef": "def"}, {"fullname": "package.util.IO.paulilabel", "modulename": "package.util.IO", "qualname": "paulilabel", "type": "function", "doc": "<p>Transforms numbers in tuples to Pauli terms</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>p (Tuple):</strong>  The (PauliString) input</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>String: 'PauliString'</p>\n</blockquote>\n", "parameters": ["p"], "funcdef": "def"}, {"fullname": "package.util.IO.tuplesToMatrix", "modulename": "package.util.IO", "qualname": "tuplesToMatrix", "type": "function", "doc": "<p>Converts a Pauli String represented as a Tuple to a matrix element that can be operated on traditionally. Generally expensive to operate with</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>coefficient (np.Complex128):</strong>  Multiplies the resultant matrix</li>\n<li>PauliTuple (Tuple)\nPauli Tuple of the form (0, 1, 2, 3) == IXYZ == kron(kron(kron(I, X), Y), Z)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>ndarray, equal to the kronecker product of the Pauli elements, multiplied by the coefficients</p>\n</blockquote>\n", "parameters": ["coefficient", "PauliTuple"], "funcdef": "def"}, {"fullname": "package.util.PauliOps", "modulename": "package.util.PauliOps", "qualname": "", "type": "module", "doc": "<p>Created on Mon Dec 21 15:16:56 2020\nA Collection of Methods to calcualte useful operations on Pauli Strings</p>\n\n<p>@author: Thomas Steckmann\n@author: Efekan Kokcu</p>\n"}, {"fullname": "package.util.PauliOps.ops", "modulename": "package.util.PauliOps", "qualname": "ops", "type": "variable", "doc": "<h6 id=\"rules\">RULES</h6>\n\n<blockquote>\n  <p>Used to find the multiplication between two paulis represented as indices in a tuple (I == 0, X == 1, Y == 2, Z == 3)</p>\n</blockquote>\n\n<p>The operation is (index1 + index2*RULES[index1] % 4) = Pauli Matrix result as an index</p>\n\n<p>I * anything: 0 + (Index2)<em>1 = index2\nX * anythong: (1 + (Index2)</em>3 % 4) gives\n                                         1 + 0 = 1 for I, \n                                         (1 + 1<em>3) % 4 = 0 for X\n                                         (1 + 2</em>3) % 4 = 7 % 4 = 3 for Y\n                                         (1 + 3*3) % 4 = 10 % 4 = 2 for Z as index2\nThese can easily be expanded for Y and Z</p>\n"}, {"fullname": "package.util.PauliOps.RULES", "modulename": "package.util.PauliOps", "qualname": "RULES", "type": "variable", "doc": "<p>SIGN_RULES: \n    Gives the multiplication sign rules for multiplying Pauli Matricies (ex. X*Y -> iZ)</p>\n\n<p>I  X  Y  Z\nI +  +  +  +\nX +  +  +i -i\nY +  -i +  +i\nZ +  +i -i +</p>\n\n<p>Order: row * column</p>\n"}, {"fullname": "package.util.PauliOps.commutatePauliString", "modulename": "package.util.PauliOps", "qualname": "commutatePauliString", "type": "function", "doc": "<p>Computes the commutator of two Pauli Strings representated as a tuple</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple, integer):</strong>   tuple represenation of the first Pauli String, or the index in the commutator table</li>\n<li><strong>b (np.complex128):</strong>   The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (tuple, int):</strong>   tuple represenation of the second Pauli String, or the index in the commutator table</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result [a<em>TupleA,b</em>TupleB] = c*TupleC, where c is the Structure Constant * a * b\n  tupleC (tuple): \n      the elementwise commutator of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "parameters": ["a", "tupleA", "b", "tupleB", "comm_coefs", "comm_table"], "funcdef": "def"}, {"fullname": "package.util.PauliOps.multiplyPauliString", "modulename": "package.util.PauliOps", "qualname": "multiplyPauliString", "type": "function", "doc": "<p>Computes the multiplication of two Pauli Strings representated as a tuple</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>a (np.complex128):</strong>   The coefficient of the first Pauli String term</li>\n<li><strong>tupleA (Tuple):</strong>  tuple represenation of the first Pauli String</li>\n<li><strong>b (np.complex128):</strong>  The coefficient of the second Pauli String term</li>\n<li><strong>tupleB (Tuple):</strong>   tuple represenation of the second Pauli String</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>c (np.complex128):\n      The coefficient of the result a<em>TupleA . b</em>TupleB = c*TupleC, where c (the sign of the product of Paulis * a * b)\n  tupleC (tuple) :\n      the elementwise product of the PauliString, ignoring coefficients.</p>\n</blockquote>\n", "parameters": ["a", "tupleA", "b", "tupleB"], "funcdef": "def"}, {"fullname": "package.util.PauliOps.multiplyLinComb", "modulename": "package.util.PauliOps", "qualname": "multiplyLinComb", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms</p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB"], "funcdef": "def"}, {"fullname": "package.util.PauliOps.simplifyLinComb", "modulename": "package.util.PauliOps", "qualname": "simplifyLinComb", "type": "function", "doc": "<p>Modifies the input lists</p>\n\n<p>Simplifies lin comb of Pauli matrices that it eats. Doens't return anything</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>A:</strong>  A list</li>\n<li><strong>tuples:</strong>  A list</li>\n</ul>\n", "parameters": ["A", "tuples"], "funcdef": "def"}, {"fullname": "package.util.PauliOps.commutateLinComb", "modulename": "package.util.PauliOps", "qualname": "commutateLinComb", "type": "function", "doc": "<p></p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB", "accur"], "funcdef": "def"}, {"fullname": "package.util.PauliOps.multiplyLinCombRound", "modulename": "package.util.PauliOps", "qualname": "multiplyLinCombRound", "type": "function", "doc": "<p>Returns multiplication of two linear combinations of Pauli terms, and rounds things that are smaller than accur to zero.</p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB", "accur"], "funcdef": "def"}, {"fullname": "package.util.PauliOps.commutateLinCombWithoutFactorOf2", "modulename": "package.util.PauliOps", "qualname": "commutateLinCombWithoutFactorOf2", "type": "function", "doc": "<p></p>\n", "parameters": ["A", "tuplesA", "B", "tuplesB", "accur"], "funcdef": "def"}, {"fullname": "package.util.PauliOps.cleancoefs", "modulename": "package.util.PauliOps", "qualname": "cleancoefs", "type": "function", "doc": "<p>Rounds coefficients that are smaller than accur to zero.</p>\n", "parameters": ["coefs", "accur"], "funcdef": "def"}, {"fullname": "package.util.verification", "modulename": "package.util.verification", "qualname": "", "type": "module", "doc": "<p>A collection of functions useful for exact diagonalization and converting KHK decomposition to a matrix</p>\n"}, {"fullname": "package.util.verification.Nident", "modulename": "package.util.verification", "qualname": "Nident", "type": "function", "doc": "<p>Generates an N qubit Identity Matrix</p>\n", "parameters": ["N"], "funcdef": "def"}, {"fullname": "package.util.verification.PauliExpUnitary", "modulename": "package.util.verification", "qualname": "PauliExpUnitary", "type": "function", "doc": "<p>Generates the Unitary Matrix for a Pauli Exponential\nUses e^{i.co.Pauli} = I<em>cos(a) + i</em>sin(a)*Pauli</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>N (int):</strong>  Number of qubits</li>\n<li><strong>co (float):</strong>  The coefficient of the Pauli Matrix</li>\n<li><strong>PauliTuple (Tuple):</strong>  (PauliString) to exp</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The result e<sup>i\u2022co\u2022PauliTuple</sup> = I\u2022cos(co) + i\u2022sin(co)\u2022PauliTuple</p>\n</blockquote>\n", "parameters": ["N", "co", "PauliTuple"], "funcdef": "def"}, {"fullname": "package.util.verification.exactU", "modulename": "package.util.verification", "qualname": "exactU", "type": "function", "doc": "<p>Computes the exact matrix exponential for time evolution at the time t</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>HCos (List of complex numbers):</strong> </li>\n<li><strong>HTupes (List of (PauliStrings)):</strong> </li>\n<li><strong>time (float - time evolution final time):</strong> </li>\n</ul>\n", "parameters": ["HCos", "HTups", "time"], "funcdef": "def"}, {"fullname": "package.util.verification.Trotter", "modulename": "package.util.verification", "qualname": "Trotter", "type": "function", "doc": "<p>Prepares U_t, the Trotterized input U</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>ham (List of Tuples):</strong>  Hamiltonian formatted as (co, (PauliString))</li>\n<li><strong>time (float):</strong>  final time to evolve to</li>\n<li><strong>N (int):</strong>  number of qubits</li>\n<li><strong>steps (int):</strong>  Number of trotter steps to take</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The U<sub>trotter</sub>(t) that approximates U<sub>exact</sub>(t)</p>\n</blockquote>\n", "parameters": ["ham", "time", "N", "steps"], "funcdef": "def"}, {"fullname": "package.util.verification.KHK", "modulename": "package.util.verification", "qualname": "KHK", "type": "function", "doc": "<p>Defines the Unitary for the KHK<sup>\u2020</sup>]</p>\n\n<p>Specifically, performs \u213f<sub>i</sub> e<sup>i\u2022k[l]\u2022kCoefs[l]</sup> \u213f<sub>j</sub> e<sup>i\u2022h[j]\u2022hCoefs[j]</sup>  \u213f<sub>l</sub> e<sup>i\u2022k[(lenK - l)]\u2022kCoefs[(lenK - l)]</sup> </p>\n\n<p>Multiply by t before passing the coefficients for h. Do not multiply h by i, that is automatic. The coefficients should be real for k, imaginary for h</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>kCoefs (List):</strong>  A list of (real) coefficients for k</li>\n<li><strong>hCoefs (List):</strong>  The list of (imaginary) coefficients for the elements in h. </li>\n<li><strong>k (List of Tuples):</strong>  The list of (PauliStrings)</li>\n<li><strong>h (List of Tuples):</strong>  List of (PauliStrings) for h (in the same indexing)</li>\n</ul>\n", "parameters": ["kCoefs", "hCoefs", "k", "h"], "funcdef": "def"}]